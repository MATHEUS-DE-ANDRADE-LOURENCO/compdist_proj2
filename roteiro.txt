Introdução
Vocês foram contratados para desenvolver o núcleo do sistema de agendamento do novo telescópio espacial acadêmico. Cientistas do mundo todo competirão por tempo de observação neste equipamento, que custa milhões de dólares por hora para operar.
O desafio é criar uma API de agendamento justa, consistente e à prova de falhas em ambiente de altíssima concorrência.

Fundamentos Teóricos
O que é um Web Service?
Um Web Service é um sistema projetado para permitir a comunicação entre diferentes máquinas através de uma rede. Ele expõe funcionalidades que podem ser requisitadas por outras aplicações, independentemente da linguagem ou sistema operacional.
O que são APIs e o Padrão REST?

API (Application Programming Interface): Contrato que define regras para comunicação entre aplicações, especificando funcionalidades disponíveis, dados necessários e respostas.
REST (REpresentational State Transfer): Estilo arquitetural para criação de Web Services.


API RESTful

Arquitetura Cliente-Servidor: Cliente (quem pede) e servidor (quem responde) são separados.
Stateless (sem estado): Cada requisição contém toda a informação necessária para ser processada. O servidor não guarda o “contexto” do cliente.
Interface uniforme:

Recursos identificados por URIs: /telescopios/hubble, /agendamentos/123
Métodos HTTP: GET (ler), POST (criar), PUT (atualizar), DELETE (remover)
Representações: recursos trocados em formato como JSON
HATEOAS (Hypermedia as the Engine of Application State): Resposta do servidor deve conter dados do recurso e links para próximas ações possíveis.




Ferramentas

Flask (Python): Microframework para desenvolvimento web. Usado para construir o Serviço de Agendamento (API principal).
Node.js (JavaScript): Ambiente de execução para tarefas concorrentes, usado para o Serviço Coordenador (controle de locks).


Desafios Centrais

Condição de corrida (exclusão mútua):
Garantir que apenas um comando de agendamento pode ser processado por vez para um mesmo horário.
Ilusão do tempo (sincronização de relógio):
Unificar a noção de tempo entre clientes para garantir justiça.
Memória do sistema (logging):
Registrar eventos para depuração e auditoria, incluindo logs de aplicação e de negócio.


Arquitetura e Tecnologias
Serviço de Agendamento (API Principal)

Linguagem/Framework: Python 3.9+ com Flask
Banco de Dados: SQLite (inicialmente) com SQLAlchemy
Responsabilidade: Gerenciar agenda, cientistas e persistência dos dados. Fonte autoritativa do estado da agenda.

Serviço de Travamento e Sincronia (Coordenador)

Linguagem/Framework: Node.js 18+ com Express.js
Responsabilidade: Coordenador centralizado para garantir exclusão mútua (serviço de “lock”) e disseminação de eventos em tempo real.


Preparação do Ambiente (Setup Inicial)


Instalar as Ferramentas:

Python 3.9+
Node.js 18+
Docker Desktop
Cliente de API (Postman ou Insomnia)



Estrutura de Pastas do Projeto (sugestão):


sctec-projeto/
  servico-agendamento/   (Python/Flask)
    venv/
    app.py
    requirements.txt
  servico-coordenador/   (Node.js/Express)
    node_modules/
    server.js
    package.json


Configuração Inicial (Serviço de Agendamento):

# Dentro da pasta /servico-agendamento
python -m venv venv
source venv/bin/activate
# No Windows: venv\\Scripts\\activate
pip install Flask Flask-SQLAlchemy
pip freeze > requirements.txt


Configuração Inicial (Serviço Coordenador):

# Dentro da pasta /servico-coordenador
npm init -y
npm install express


Colaboração entre Serviços

Dois sistemas independentes que conversam entre si para atingir um objetivo comum.
Cérebro (Flask): Lógica de negócio, persistência, validação.
Porteiro (Node.js): Controle de acesso, gerenciamento de locks.


Fluxo de Requisição: Sincronização e Concorrência
Etapa 1: Sincronização do Relógio

Cliente faz GET /time ao Flask.
Flask responde com tempo oficial.
Cliente ajusta relógio local usando Algoritmo de Cristian.

Etapa 2: Agendamento Concorrente

Flask recebe POST /agendamentos (timestamp sincronizado).
Flask solicita lock ao Node.js.
Se lock concedido, salva agendamento; se negado, retorna erro 409.
Libera lock após operação.


Exemplos de Logs
Log de Auditoria (JSON)
{
  "timestamp_utc": "2025-10-26T18:00:05.123Z",
  "level": "AUDIT",
  "event_type": "AGENDAMENTO_CRIADO",
  "service": "servico-agendamento",
  "details": {
    "agendamento_id": 123,
    "cientista_id": 7,
    "horario_inicio_utc": "2025-12-01T03:00:00Z"
  }
}

Log de Aplicação
INFO:2025-10-26T18:00:04.500Z:servico-agendamento:Requisição recebida para POST /agendamentos
INFO:2025-10-26T18:00:04.505Z:servico-agendamento:Tentando adquirir lock para o recurso Hubble-Acad_2025-12-01T03:00:00Z
INFO:2025-10-26T18:00:05.120Z:servico-agendamento:Lock adquirido com sucesso
INFO:2025-10-26T18:00:05.122Z:servico-agendamento:Iniciando verificação de conflito no BD
INFO:2025-10-26T18:00:05.123Z:servico-agendamento:Salvando novo agendamento no BD
INFO:2025-10-26T18:00:05.121Z:servico-agendamento:Falha ao adquirir lock, recurso ocupado


Entregas do Projeto em Etapas
Entrega 1: Blueprint da API

MODELOS.md: Definição das entidades.
API.md: Descrição dos endpoints e HATEOAS.
LOGGING.md: Estrutura dos logs de auditoria e aplicação.

Entrega 2: Sistema Inicial

Implementação básica do Flask/SQLAlchemy.
Logging de aplicação e auditoria.
Script de teste de estresse para provar condição de corrida.

Entrega 3: Serviço Coordenador

Implementação do servidor Express (Node.js).
Logging no coordenador.
Integração entre Flask e Node.js para controle de locks.

Entrega 4: Sincronização de Tempo e Cliente Inteligente

Endpoint GET /time no Flask.
Interface web para sincronização de tempo.
Uso de HATEOAS para cancelamento de agendamento.
Logging de cancelamento.

Entrega 5: Orquestração com Docker

Dockerfile para ambos os serviços.
docker-compose.yml para orquestração.
Validação dos logs centralizados via docker-compose logs -f.


Critérios de Avaliação

MODELOS.md completo.
API.md detalhando endpoints e respostas HATEOAS.
Seção ou arquivo definindo o formato padrão para os logs.
Código funcional dos serviços.
Testes que provam exclusão mútua e sincronização.
Orquestração e observabilidade dos logs.


Observações Finais

O sistema deve garantir justiça, exclusão mútua e rastreabilidade.
A arquitetura de microserviços facilita escalabilidade e manutenção.
Docker e Docker Compose são essenciais para orquestração e observabilidade.

